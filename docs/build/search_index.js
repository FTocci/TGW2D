var documenterSearchIndex = {"docs":
[{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"Progetto TGW2D per il corso di Calcolo Parallelo e Distribuito svolto da:","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"Nome E-mail\nMatteo Maraziti mat.maraziti@stud.uniroma3.it\nFederico Tocci fed.tocci@stud.uniroma3.it\nGiacomo Scordino gia.scordino1@stud.uniroma3.it","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"STUDIO PRELIMINARE","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"Il topological gift wrapping è un algoritmo che produce un insieme di complessi di catene in 2D.","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"Data una qualsiasi collezione di poliedri cellulari la computazione può essere riassunta con i seguenti passaggi:","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"Estrarre i due scheletri dei poliedri;\nFondere in modo efficiente tutte le loro 2-celle;\nCalcolare su ogni 2-cella il suo complesso di catene locale.","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"Con tali premesse, l’obiettivo del presente elaborato è stato quello di effettuare una analisi preliminare del codice a disposizione, individuando i compiti principali che l’algoritmo svolge, le dipendenze fra le varie funzione che lo compongono e determinare eventuali criticità su cui è necessario intervenire.[2]","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"1.1 Il linguaggio Julia","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"L’algoritmo appena introdotto utilizza Julia come linguaggio di programmazione. Esso è stato creato con l’intento di garantire alte prestazioni, sfruttando a pieno le potenzialità del calcolo parallelo. È possibile utilizzare primitive che permettono di sfruttare a pieno i core delle macchine sulle quali viene messo in esecuzione il codice Julia, grazie al meccanismo di multi-threading.","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"Julia può inoltre generare codice nativo per GPU, risorsa che permette di abbattere ulteriormente i tempi di esecuzione dell’algoritmo.[1]","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"1.2 Funzionamento","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"L’algoritmo è utilizzato localmente su 2-cella per essere decomposta, e invece utilizzato globalmente per generare le 3-celle della partizione dello spazio.","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"(Image: EstrazioneCicloMinimale)","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"Figura 1 : Estrazione di 1 ciclo minimale [2]","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"Per ogni elemento (1-scheletro) calcolo il bordo ottenendo i due vertici, per ciascun vertice calcolo il cobordo, ovvero individuo gli altri elementi (1-scheletro) con un vertice coincidente (questo passaggio viene effettuato tramite valori matriciali). A questo punto si isolano due elementi tra quelli individuati formando così una catena e si ripete l’algoritmo sugli elementi della catena appena calcolata. L’obiettivo di ciascuna iterazione è quello di individuare una porzione nel piano (ovvero la 1-catena di bordo) Figura 1. [2]","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"1.2.1 Illustrazione dello pseudocodice","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"Lo pseudocodice in Figura 2 è il riassunto dell’algoritmo TGW in uno spazio generico di D-dimensionale.","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"L’algoritmo prende in input una matrice sparsa di dimensioni “m×n” e restituisce una matrice dal dominio delle D-catene a quello dei (d-1) cicli orientati. [3]","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"(Image: pseudocodice)","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"Figura 2: pseudocodice [3]","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"1.3 Funzioni interne principali","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"1.3.1 Planar Arrangement","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"function planar_arrangement(\n        V::Lar.Points,\n        copEV::Lar.ChainOp,\n        sigma::Lar.Chain=spzeros(Int8, 0),\n        return_edge_map::Bool=false,\n        multiproc::Bool=false)\n#planar_arrangement_1\n\tV,copEV,sigma,edge_map=Lar.Arrangement.planar_arrangement_1(V,copEV,sigma,return_edge_map,multiproc)\n# cleandecomposition\n\tif sigma.n > 0\n\t\tV,copEV=Lar.Arrangement.cleandecomposition(V, copEV, sigma, edge_map)\n\tend\n    bicon_comps = Lar.Arrangement.biconnected_components(copEV)\n    # EV = Lar.cop2lar(copEV)\n    # V,bicon_comps = Lar.biconnectedComponent((V,EV))\n\tif isempty(bicon_comps)\n    \tprintln(\"No biconnected components found.\")\n    \tif (return_edge_map)\n    \t    return (nothing, nothing, nothing, nothing)\n    \telse\n    \t    return (nothing, nothing, nothing)\n    \tend\n\tend\n#Planar_arrangement_2\n\tV,copEV,FE=Lar.Arrangement.planar_arrangement_2(V,copEV,bicon_comps,edge_map,sigma)\n\tif (return_edge_map)\n\t     return V, copEV, FE, edge_map\n\telse\n\t     return V, copEV, FE\n\tend\nend","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"L’obiettivo è partizionare un complesso cellulare passato come parametro. Un complesso cellulare è partizionato quando l'intersezione di ogni possibile coppia di celle del complesso è vuota e l'unione di tutte le celle è l'intero spazio euclideo.","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"1.3.2 Merge Vertices","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"function merge_vertices!(V::Lar.Points, EV::Lar.ChainOp, edge_map, err=1e-4)\n    vertsnum = size(V, 1)\n    edgenum = size(EV, 1)\n    newverts = zeros(Int, vertsnum)\n    # KDTree constructor needs an explicit array of Float64\n    V = Array{Float64,2}(V)\n    kdtree = KDTree(permutedims(V))\n\n    # merge congruent vertices\n    todelete = []\n    i = 1\n    for vi in 1:vertsnum\n        if !(vi in todelete)\n            nearvs = Lar.inrange(kdtree, V[vi, :], err)\n            newverts[nearvs] .= i\n            nearvs = setdiff(nearvs, vi)\n            todelete = union(todelete, nearvs)\n            i = i + 1\n        end\n    end\n    nV = V[setdiff(collect(1:vertsnum), todelete), :]\n\n    # merge congruent edges\n    edges = Array{Tuple{Int, Int}, 1}(undef, edgenum)\n    oedges = Array{Tuple{Int, Int}, 1}(undef, edgenum)\n    for ei in 1:edgenum\n        v1, v2 = EV[ei, :].nzind\n        edges[ei] = Tuple{Int, Int}(sort([newverts[v1], newverts[v2]]))\n        oedges[ei] = Tuple{Int, Int}(sort([v1, v2]))\n    end\n    nedges = union(edges)\n    nedges = filter(t->t[1]!=t[2], nedges)\n    nedgenum = length(nedges)\n    nEV = spzeros(Int8, nedgenum, size(nV, 1))\n    # maps pairs of vertex indices to edge index\n    etuple2idx = Dict{Tuple{Int, Int}, Int}()\n    # builds `edge_map`\n    for ei in 1:nedgenum\n        nEV[ei, collect(nedges[ei])] .= 1\n        etuple2idx[nedges[ei]] = ei\n    end\n    for i in 1:length(edge_map)\n        row = edge_map[i]\n        row = map(x->edges[x], row)\n        row = filter(t->t[1]!=t[2], row)\n        row = map(x->etuple2idx[x], row)\n        edge_map[i] = row\n    end\n    # return new vertices and new edges\n    return Lar.Points(nV), nEV\nend","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"Si occupa di fondere vertici congruenti e bordi congruenti, assegnare a coppie di indici di vertici indici di bordo e costruire una mappa dei bordi.","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"1.3.3 Frag Edge","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"function frag_edge(V, EV::Lar.ChainOp, edge_idx::Int, bigPI)\n    alphas = Dict{Float64, Int}()\n    edge = EV[edge_idx, :]\n    verts = V[edge.nzind, :]\n    for i in bigPI[edge_idx]\n        if i != edge_idx\n            intersection = Lar.Arrangement.intersect_edges(\n            \tV, edge, EV[i, :])\n            for (point, alpha) in intersection\n                verts = [verts; point]\n                alphas[alpha] = size(verts, 1)\n            end\n        end\n    end\n    alphas[0.0], alphas[1.0] = [1, 2]\n    alphas_keys = sort(collect(keys(alphas)))\n    edge_num = length(alphas_keys)-1\n    verts_num = size(verts, 1)\n    ev = SparseArrays.spzeros(Int8, edge_num, verts_num)\n    for i in 1:edge_num\n        ev[i, alphas[alphas_keys[i]]] = 1\n        ev[i, alphas[alphas_keys[i+1]]] = 1\n    end\n    return verts, ev\nend","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"Si occupa della frammentazione dei bordi in EV usando l'indice spaziale bigPI.","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"1.4 Analisi per il miglioramento del codice ","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"Analizzando il codice nel dettaglio, è possibile evidenziare che in alcuni passi dell'algoritmo è stato implementato il calcolo parallelo e distribuito. Infatti, nella funzione \"planar_arrangement_1\", la frammentazione dei bordi può essere effettuata tramite il calcolo asincrono. ","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"Continuando l'analisi del codice ed osservando accuratamente le dipendenze presenti risulta opportuno implementare modifiche con l'obiettivo di migliorare scalabilità, modificabilità e prestazioni di porzioni dello stesso, riducendo l'accoppiamento tra i moduli presenti fattorizzando il codice e continuando ad implementare forme di calcolo parallelo e distribuito. In particolare, alcune di queste modifiche dovranno coinvolgere il codice relativo alla funzione \"merge_vertices!\", presentata in precedenza. Infatti, ad essa sono assegnate numerose task che possono essere suddivise in diverse sotto funzioni.","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"STUDIO ESECUTIVO","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"All’interno di questo capitolo verrà trattato lo sviluppo del progetto nella sua fase principale, ovvero quella riguardante la messa in atto di tutte le modifiche introdotte nel capitolo precedente.","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"Lo scopo principale è quello di migliorare le prestazioni dell’algoritmo preso in esame andando ad introdurre all’interno del codice porzioni che presentano la possibilità di essere eseguite in parallelo. Oltre a ciò, un secondo obiettivo è la re-fattorizzazione di alcune funzione, garantendo migliore scalabilità e modificabilità dei moduli interessati.","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"2.1 Calcolo Parallelo in Julia","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"Come introdotto nei paragrafi precedenti è stato deciso di migliorare le prestazioni dell’algoritmo usufruendo delle potenzialità garantite dal calcolo parallelo. Nei prossimi paragrafi verranno illustrate le possibili implementazioni del calcolo parallelo offerta dal linguaggio di programmazione Julia.","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"2.1.1 ***Task* asincroni o coroutine**","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"I task di Julia consentono di sospendere e riprendere i calcoli per l'I/O, la gestione degli eventi e modelli simili. I task possono sincronizzarsi attraverso operazioni come wait e fetch e comunicare tramite canali. Pur non essendo di per sé un calcolo parallelo, Julia consente di programmare i task su più thread.","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"2.1.2 Multithreading","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"Il multithreading di Julia offre la possibilità di programmare task simultaneamente su più di un thread o core della CPU, condividendo la memoria. Questo è di solito il modo più semplice per ottenere il parallelismo sul proprio PC o su un singolo grande server multicore.","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"2.1.3 Elaborazione distribuita","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"il calcolo distribuito esegue più processi Julia con spazi di memoria separati. Questi possono trovarsi sullo stesso computer o su più computer. La libreria standard Distributed fornisce la possibilità di eseguire in remoto una funzione Julia. Con questo blocco di base, è possibile costruire molti tipi diversi di astrazioni di calcolo distribuito.","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"2.1.4 Elaborazione su GPU","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"Il compilatore Julia GPU offre la possibilità di eseguire codice Julia in modo nativo sulle GPU. Esiste un ricco ecosistema di pacchetti Julia che puntano alle GPU.","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"2.2 Analisi Codice ","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"Prima dell’attuazione delle modifiche è stata svolta un’analisi dell’algoritmo con l’obiettivo di misurarne i tempi di esecuzione e di individuare eventuali porzioni di codice che potessero rallentare notevolmente l’esecuzione dello stesso.","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"In tal senso, Julia offre strumenti che possono aiutare a diagnosticare i problemi e a migliorare le prestazioni del codice. Per questa fase di studio dell’algoritmo sono stati usati: ","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"Profiling: La profilazione consente di misurare le prestazioni del codice in esecuzione e di identificare le linee che fungono da colli di bottiglia. Per la visualizzazione dei risulati è stato usato il pacchetto ProfileView [4]. (Figura 6)\n@time: Una macro che esegue un'espressione, stampando il tempo di esecuzione, il numero di allocazioni e il numero totale di byte che l'esecuzione ha causato, prima di restituire il valore dell'espressione [5]. (Figura 7)","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"(Image: Profiling)","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"Figura 3: Risultato Profiling","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"(Image: RisultatiTestIniziale)","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"Figura 4: Risultati test iniziale","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"2.3 Implementazione delle modifiche  All’interno dell’algoritmo è evidente una elevata presenza di cicli, molti dei quali annidati. Per questo motivo è stato scelto di utilizzare la tecnica del Multi-threading. Julia supporta i loop paralleli utilizzando la macro Threads.@threads. Questa macro viene apposta davanti a un ciclo for per indicare a Julia che il ciclo è una regione multi-thread. ","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"Lo spazio di iterazione viene suddiviso tra i thread, dopodiché ogni thread scrive il proprio ID thread nelle posizioni assegnate.   Prima di eseguire un programma Julia multithread, è necessario impostare il numero di thread. Questo puo essere impostato dalla linea di comando di Julia, utilizzando gli argomenti della riga di comando -t, o modificando la variabile d'ambiente JULIANUMTHREADS.[6]","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"A seguito delle modifiche sono stati eseguiti nuovamente i test ottenendo i risultati illustrati nella Figura 8.","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"(Image: RisutatiTestFinale)","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"Figura 5: Risultati test finale","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"Osservando i tempi misurati prima e dopo delle modifiche si evince un miglioramento della prestazione di circa il 30%.","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"2.4 Re-fattorizzazione","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"Come anticipato nei paragrafi sopra è stato scelto di aggiungere alcune nuove funzioni all’interno del codice così da ridurre le responsabilità di alcuni metodi già presenti nello stesso. Questa scelta implementativa ha coinvolto prevalentemente la funzione “merge_vertices”, il cui corpo al termine delle modifiche è risultato notevolemente piu leggibile. In particolare, le funzioni che sono state aggiunte al codice sono mergeCongruentVertices (Figura 9), mergeCongruentEdges (Figura 10), buildEdgeMap (Figura 11).  ","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"function mergeCongruentVertices(vertsnum,newverts,kdtree,V,err=1e-4)\n    todelete = []\n    i = 1\n    for vi in 1:vertsnum\n        if !(vi in todelete)\n            nearvs = Lar.inrange(kdtree, V[vi, :], err)\n            newverts[nearvs] .= i\n            nearvs = setdiff(nearvs, vi)\n            todelete = union(todelete, nearvs)\n            i = i + 1\n        end\n    end\n    return todelete,newverts\nend\n\nfunction mergeCongruentEdges(edgenum,newverts,EV)\n    edges = Array{Tuple{Int, Int}, 1}(undef, edgenum)\n    oedges = Array{Tuple{Int, Int}, 1}(undef, edgenum)\n    @sync begin\n        for ei in 1:edgenum\n            @async begin\n                v1, v2 = EV[ei, :].nzind\n                edges[ei] = Tuple{Int, Int}(sort([newverts[v1], newverts[v2]]))\n                oedges[ei] = Tuple{Int, Int}(sort([v1, v2])) \n            end\n        end \n    end\n    return edges,oedges\nend\n\nfunction buildEdgeMap(nedges,nedgenum,nEV,etuple2idx,edge_map,edges)\n    for ei in 1:nedgenum\n        nEV[ei, collect(nedges[ei])] .= 1\n        etuple2idx[nedges[ei]] = ei\n    end\n    \n    for i in 1:length(edge_map)\n        row = edge_map[i]\n        row = map(x->edges[x], row)\n        row = filter(t->t[1]!=t[2], row)\n        row = map(x->etuple2idx[x], row)\n        edge_map[i] = row \n    end        \n    return edge_map,nEV\nend","category":"page"},{"location":"#**BIBLIOGRAFIA**","page":"Topological Gift Wrapping 2D","title":"BIBLIOGRAFIA","text":"","category":"section"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"[1]: Julia doc: https://julialang.org/","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"[2]: ACM-TSAS-2020 Section on Topological gift wrapping (TGW) in 2D in particular 2.3, 2.4 ","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"[3]: CADJ-2021.pdf Section on Chains and Arrangements in particular 2.2. and A.1. Relevant matters (Algorithm 5)","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"[4] Profiling:  https://docs.julialang.org/en/v1/manual/profile/","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"[5] <Base.@time>: https://docs.julialang.org/en/v1/base/base/#Base.@time","category":"page"},{"location":"","page":"Topological Gift Wrapping 2D","title":"Topological Gift Wrapping 2D","text":"[6] MultiThreading: https://docs.julialang.org/en/v1/manual/multi-threading/#The-@threads-Macro","category":"page"}]
}
