var documenterSearchIndex = {"docs":
[{"location":"intro/#Topological-Gift-Wrapping-2D-TGW2D","page":"Introduzione","title":"Topological Gift Wrapping 2D - TGW2D","text":"","category":"section"},{"location":"intro/","page":"Introduzione","title":"Introduzione","text":"Il topological gift wrapping è un algoritmo che produce un insieme di complessi di catene in 2D.  Data una qualsiasi collezione di poliedri cellulari la computazione può essere riassunta con i seguenti passaggi:","category":"page"},{"location":"intro/","page":"Introduzione","title":"Introduzione","text":"Estrarre i due scheletri dei poliedri;\nFondere in modo efficiente tutte le loro 2-celle;\nCalcolare su ogni 2-cella il suo complesso di catene locale.","category":"page"},{"location":"intro/","page":"Introduzione","title":"Introduzione","text":"Con tali premesse, l’obiettivo del presente elaborato è stato quello di effettuare una analisi preliminare del codice a disposizione, individuando i compiti principali che l’algoritmo svolge, le dipendenze fra le varie funzione che lo compongono e determinare  eventuali criticità su cui è necessario intervenire.","category":"page"},{"location":"intro/#Linguaggio-Julia","page":"Introduzione","title":"Linguaggio Julia","text":"","category":"section"},{"location":"intro/","page":"Introduzione","title":"Introduzione","text":"L’algoritmo appena introdotto utilizza Julia come linguaggio di programmazione. Essoè stato creato con l’intento di garantire alte prestazioni, sfruttando a pieno lepotenzialità  del calcolo parallelo. È possibile utilizzare primitive che permettono di sfruttare a pieno i core delle macchine sulle quali viene messo in esecuzione il codiceJulia, grazie al  meccanismo di multi-threading. Julia può inoltre generare codice nativo per GPU, risorsa che permette di abbattere ulteriormente i tempi di esecuzione dell’algoritmo.","category":"page"},{"location":"intro/#Funzionamento","page":"Introduzione","title":"Funzionamento","text":"","category":"section"},{"location":"intro/","page":"Introduzione","title":"Introduzione","text":"L’algoritmo è utilizzato localmente su 2-cella per essere decomposta, e invece utilizzato  globalmente per generare le 3-celle della partizione dello spazio.","category":"page"},{"location":"intro/","page":"Introduzione","title":"Introduzione","text":"(Image: Cycle Extraction)","category":"page"},{"location":"intro/","page":"Introduzione","title":"Introduzione","text":"Per ogni elemento (1-scheletro) calcolo il bordo ottenendo i due vertici, per ciascun vertice calcolo il cobordo, ovvero individuo gli altri elementi (1-scheletro) con un vertice  coincidente (questo passaggio viene effettuato tramite valori matriciali). A questo punto  si isolano due elementi tra quelli individuati formando così una catena e si ripete  l’algoritmo sugli elementi della catena appena calcolata. L’obiettivo di ciascuna iterazione è quello di individuare una porzione nel piano (ovvero la 1-catenadi bordo)","category":"page"},{"location":"intro/#Illustrazione-dello-pseudocodice","page":"Introduzione","title":"Illustrazione dello pseudocodice","text":"","category":"section"},{"location":"intro/","page":"Introduzione","title":"Introduzione","text":"Lo pseudocodice è il riassunto dell’algoritmo TGW in uno spazio generico di D-dimensionale. L’algoritmo prende in input una matrice sparsa di dimensioni “m×n” e restituisce una matrice dal dominio delle D-catene a quello dei (d-1) cicli orientati.","category":"page"},{"location":"intro/","page":"Introduzione","title":"Introduzione","text":"(Image: pseudocode)","category":"page"},{"location":"grafodipendenze/#Grafo-delle-Dipendenze","page":"Grafo delle Dipendenze","title":"Grafo delle Dipendenze","text":"","category":"section"},{"location":"grafodipendenze/","page":"Grafo delle Dipendenze","title":"Grafo delle Dipendenze","text":"In questa sezione è rappresentato il grafo orientato delle dipendenze della base di codice oggetto di studio. Ogni arco orientato rappresenta una chiamata di funzione (v_1 v_2), dove v_1 è la funzione chiamante, e v_2 è la funzione chiamata. I nodi hanno un’etichetta corrispondente al nome della funzione. Gli archi invece hanno una etichetta numerica consecutiva corrispondente all’ordine delle chiamate dal nodo loro origine.","category":"page"},{"location":"grafodipendenze/","page":"Grafo delle Dipendenze","title":"Grafo delle Dipendenze","text":"(Image: image)","category":"page"},{"location":"grafodipendenze/","page":"Grafo delle Dipendenze","title":"Grafo delle Dipendenze","text":"(Image: image)","category":"page"},{"location":"grafodipendenze/","page":"Grafo delle Dipendenze","title":"Grafo delle Dipendenze","text":"(Image: image)","category":"page"},{"location":"grafodipendenze/","page":"Grafo delle Dipendenze","title":"Grafo delle Dipendenze","text":"(Image: image)","category":"page"},{"location":"grafodipendenze/","page":"Grafo delle Dipendenze","title":"Grafo delle Dipendenze","text":"(Image: image)","category":"page"},{"location":"grafodipendenze/","page":"Grafo delle Dipendenze","title":"Grafo delle Dipendenze","text":"(Image: image)","category":"page"},{"location":"grafodipendenze/","page":"Grafo delle Dipendenze","title":"Grafo delle Dipendenze","text":"(Image: image)","category":"page"},{"location":"conclusioni/#Conclusioni-e-Sviluppi-Futuri","page":"Conclusione","title":"Conclusioni e Sviluppi Futuri","text":"","category":"section"},{"location":"conclusioni/","page":"Conclusione","title":"Conclusione","text":"Nonostante le modifiche apportate all'algoritmo sostengano maggiormente le prestazioni riducendo il tempo di esecuzione, sviluppi futuri possono prevedere l'impiego di tecnologie come:","category":"page"},{"location":"conclusioni/","page":"Conclusione","title":"Conclusione","text":"'Distributed Workers' - In questo modo i processi Julia verrebbero eseguiti con spazi di memoria separati, garantendo prestazioni ancora maggiori.","category":"page"},{"location":"conclusioni/","page":"Conclusione","title":"Conclusione","text":"'Asynchronous Tasks' - Consentono di sospendere e riprendere i calcoli per I/O e gestione di eventi. I Tasks possono sincronizzarsi tramite la comunicazione per mezzo dei canali.","category":"page"},{"location":"#TGW2D","page":"Informazioni Generali","title":"TGW2D","text":"","category":"section"},{"location":"","page":"Informazioni Generali","title":"Informazioni Generali","text":"Progetto Topological Gift Wrapping 2D per Calcolo Parallelo e Distribuito sviluppato da:","category":"page"},{"location":"","page":"Informazioni Generali","title":"Informazioni Generali","text":"Nome Matricola E-mail Github Profile\nMatteo Maraziti 534932 mat.maraziti@stud.uniroma3.it https://github.com/matteomaraziti\nFederico Tocci 533449 fed.tocci@stud.uniroma3.it https://github.com/FTocci\nGiacomo Scordino 533393 gia.scordino1@stud.uniroma3.it https://github.com/GiacomoScordino","category":"page"},{"location":"","page":"Informazioni Generali","title":"Informazioni Generali","text":"Documentazione: https://ftocci.github.io/TGW2D/build/  ","category":"page"},{"location":"","page":"Informazioni Generali","title":"Informazioni Generali","text":"Repository: https://github.com/FTocci/TGW2D","category":"page"},{"location":"","page":"Informazioni Generali","title":"Informazioni Generali","text":"Notebooks:","category":"page"},{"location":"","page":"Informazioni Generali","title":"Informazioni Generali","text":"Studio Preliminare: https://github.com/FTocci/TGW2D/blob/main/notebooks/NotebookPreliminare.ipynb\nStudio Esecutivo - Finale: https://github.com/FTocci/TGW2D/blob/main/notebooks/NotebookFinale.ipynb","category":"page"},{"location":"#Rapid-Explanation-(for-English-Users)","page":"Informazioni Generali","title":"Rapid Explanation (for English Users)","text":"","category":"section"},{"location":"","page":"Informazioni Generali","title":"Informazioni Generali","text":"The Topological Gift Wrapping repository contains functions for computing the arrangement on the given cellular complex 1-skeleton in 2D. A cellular complex is arranged when the intersection of every possible pair of cell of the complex is empty and the union of all the cells is the whole Euclidean space. The basic method of the function without the sigma, return_edge_map and multiproc arguments returns the full arranged complex V, EV and FE.","category":"page"}]
}
